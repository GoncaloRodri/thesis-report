%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}%

\chapter{TTT Prototype and Implementation}\label{cha:implementation}

In this chapter, we explore the implementation and prototyping details of TTT solution. We provide a comprehensive overview of the design choices, technologies used, and the development process that led to the creation of the TTT prototype. We also discuss the complexities involved in the implementation and how we addressed them to ensure a robust and effective solution. 
Finally, address the availability of the prototype for further research and development with an in depth guide on the installation and setup process, as well as a walkthrough on the deployment of a private network for validation and testing of this work. 

\section{Prototype Overview}\label{sec:prototype_overview}

The TTT prototype is designed to enhance the Tor network's against traffic analysis attacks by implementing 2 features on the Tor software: the \textbf{TTT Privacy Schedulers} and the \textbf{Packet Padding Cells} (PPCs). We extended the Tor source code, version \texttt{0.4.9.1-alpha-dev}, using \texttt{C} programming language, and integrated these components, together with a simple and modular library and a set of helping scripts for testing, preserving the original Tor's stack, extending its functionalities and improving privacy guarantees.

Tor Schedulers are responsible for deciding when circuits should send pending traffic and handling the circuits' cell queues.  Our TTT schedulers are very similar to the original and KIST Tor schedulers, but, instead of running on fixed time intervals, these intervals between executions are variable and randomized. All Tor's schedulers consist on a collection of function pointers, which are used to call the appropriate functions for each scheduler. Among these functions, every implementation must provide two mandatory functions: \texttt{schedule} and \texttt{run}. As the name suggests, the \texttt{schedule} function is responsible for scheduling the next execution of the scheduler, while the \texttt{run} function is the most important, and it is responsible for executing the scheduler logic, which includes deciding which circuits should send pending traffic.
In our solution, we focus on surgically modifying the \texttt{scheduler} function to calculate and schedule the next execution based on a pseudo-random time interval, based on the user's configuration.  
Also, Tor unpacks TLS packets, retrieves all cells that it may contain, and then assigns each cell to a correspondent circuit queue. Our Packet Padding Cells prototype modifies this pipeline by adding an extra step, where a false copy of the cells is created and added the queue.

To respect the modular design of Tor and its community guidelines, we also implemented a library of pseudo-random number generation based on mathematical distributions and Differential Privacy mechanisms. This library contains 2 main public functions: \texttt{dp\_generate\_int} and \texttt{dp\_generate\_bool}, which generate a pseudo-random integer and boolean, respectively. The first one uses a given minimum, maximum and target integers, an $\epsilon$ value and the mathematical distribution to generate a pseudo-random integer, inside the given interval, with center in target and uses $\epsilon$ as a Differential Privacy-inspired privacy parameter. The second one only uses a given $\epsilon$ value and a true decision to generate a differential private boolean. These functions are used in the TTT Schedulers and PPCs to generate randomized decisions, respectively, but may be used in other components in the future, given the modular design of the library.
The Tor Configuration, as mentioned in the previous chapter, uses a \texttt{torrc} file to configure the Tor software. We extended this configuration file with the before-mentioned parameters.

Finally, to assist the implementation and testing of our solution in a more efficient and automated way, we also developed a set of scripts for validation, testing, extracting and plotting the results of the TTT prototype.  
This collection of scripts can be split into 3 individual scripts.
The \textit{Tester} is a \textit{Bash} script that runs the TTT prototype in a \textit{Docker Swarm} or \textit{Docker Compose} environment, using the implemented Tor code. This script uses a \textit{YAML} configuration file in order to allow the user to specify the parameters of the TTT prototype, such as the number of \texttt{curl} requests, the size of the file to download, all needed PPC and Scheduler parameters, for each test, among other parameters. It supports both individual configuration of each test and a parameter combination mode, where the user can specify a set of parameters and the script will generate all possible combinations of those parameters to run the tests. This complex script is also responsible for building the needed \textit{Docker} images and for collecting the output of the tests and storing them in a predefined folder.
The \textit{Analyzer} is a \textit{Python} script that parses the output of the previous script, extracting the relevant performance information from the \texttt{curl} output, such as the \textit{HTTP} code, the throughput, the total time and the time to first byte of each request. The Tor relays' logs of each test are also parsed, extracting the relevant information such as the number of TLS packets and cells received, the number of Packet Padding Cells created, and the jitter condition experienced of each node. Finally, this script generates a \textit{JSON} file with all the extracted information, such as mean, minimum, maximum and standard deviation of each metric, for each test, which is then used by the \textit{Plotter} script to generate the plots.
The \textit{Plotter} is also a \textit{Python} script that uses the \textit{Pandas} and \textit{Matplotlib} libraries to generate plots, such as the ones used in~\autoref{cha:validation}. 


\section{Technologies and Techniques}\label{sec:technologies_and_techniques}

The TTT prototype is an extension of the Tor project, developed in \textit{C} programming language, leveraging the existing Tor codebase and libraries, and adding new features and functionalities.

To implement both the TTT KIST and Vanilla schedulers, we created two new files: \texttt{scheduler\_privacy\_kist.c} and \texttt{scheduler\_privacy\_vanilla.c}, each inspired by the original KIST and Vanilla schedulers, respectively, modifying some functions such as the ones stated in the previous section. 
To enhance the privacy the original schedulers provided, we used a mathematical distribution to generate a pseudo-random time interval, in the \texttt{schedule} function, for the next execution of the scheduler. After each scheduler execution, the scheduler is responsible for scheduling its next execution, and with our modification, we are able to apply a variable, random and different time interval between each scheduling. Over time, this allows for a more dynamic and less predictable scheduling pattern, which are reproduced in the traffic that exits the node.
It is also important to note that the time intervals is only set after the scheduling of a scheduler run, to avoid performance time penalties.

By extending the \texttt{relay.c} file, which handles cell encryption and decryption, packaging and receiving from circuits and queuing on circuits, we were able to implement the Packet Padding Cells feature. We modified the \texttt{circuit\_receive\_relay\_cell} function by adding an extra step after successfully queuing a received cell, where accordingly with a given probability, a new cell with a random payload is created and enqueued in the same circuit queue of the original cell. This probability is defined by the \texttt{DummyCellEpsilon} configuration parameter which then is used to generate a differential private boolean, using the \texttt{dp\_generate\_bool} function, to decide whether to create a new cell or not.  

Our library gives Tor source code the possibility to  generate pseudo-random decisions and numbers, using Differential Privacy and mathematical distributions. At the moment of writing, the library supports the \textit{Laplace}, \textit{Poisson}, \textit{Exponential}, \textit{Uniform} and \textit{Normal} distributions for generating pseudo-random numbers, and the Randomized Response algorithm for generating pseudo-random decisions, as showed in~\autoref{lst:randomized_response}.
\begin{lstlisting}[language=C, caption={Randomized Response algorithm implementation.}, label={lst:randomized_response}]
  bool randomized_response(bool true_value, double epsilon)
  {
    if (epsilon < 0.0) {
      return true_value; // If epsilon is negative, return the true value
    }
    double p = exp(epsilon) / (exp(epsilon) + 1.0);

    if (uniform() < p) {
      return true_value;
    }
    return !true_value;
  }
\end{lstlisting}

To achieve a configurable and flexible solution, we extended the Tor configuration file, \texttt{torrc}, with new parameters that allow users to configure the Tor program with the TTT prototype features. Thus, we extended the 
\texttt{config.c} and \texttt{or\_options\_st.h} which are responsible for parsing the Tor configuration file and storing the options in the \texttt{or\_options} structure during runtime, respectively, to accept new configuration keys listed in~\autoref{sec:parameterization}.

The Tester script is written in Bash and uses \textit{Docker Swarm} or \textit{Docker Compose} to deploy the Tor network with the TTT prototype. It uses the \texttt{yq} and \texttt{jq} tools to parse the \textit{YAML} and \textit{JSON} files, respectively, and the \texttt{curl} command to execute the tests' \textit{HTTP} requests and to simulate user traffic, such as browsing or download a file. It also uses the \texttt{grep} command to parse the state of the network based on the Tor logs, \texttt{ssh} and \texttt{scp} commands to interact and transfer files from the different rented machines used for testing. By using \textit{Docker}, we are able to create a controlled and easy-to-deploy environment, both for an emulated and local and a distributed deployment, allowing us to run the tests in a consistent and reproducible way for all test bench scenarios. 
The \textit{Analyzer} scripts is written in \textit{Python} and uses \textit{NumPy} library to calculate the statistics of the extracted data such as mean and standard deviation (for throughput and total time) and 10th, 50th and 90th percentiles (for time to first byte).   
The \textit{Plotter} script is written in \textit{Python} and uses \textit{Pandas} and \textit{Matplotlib} libraries to generate plots based on the \textit{Analyzer} script output.

The deployment was performed using \textit{Docker} given its flexibility and ease of use, allowing us to create a controlled environment for testing and validation, for both emulated and distributed scenarios. We also considered using Shadow~\cite{shadow-ndss2012} given that it was the tool used to test the KIST scheduler~\cite{KIST} but ultimately decided against it due to its complexity and lack of expertise in comparison to the \textit{Docker} ecosystem. Furthermore, using Docker lead to a very smooth and easy transition between both scenarios, but only changing Docker Compose files. 


\section{Complexity Analysis}\label{sec:complexity_analysis}

To implement, validate and test the TTT prototype, we extended the Tor source code with 2 new schedulers and the Packet Padding Cells feature, extended the Tor configuration file and created a library of mathematical distributions and Differential Privacy mechanisms. We also developed a set of scripts to automate the testing, validation and analysis of the TTT prototype. To understand the complexity of our work we break down the more technical details of the presented work.

To successfully extend the Tor source coded and implement the abovementioned features, we had to understand the Tor architecture, how each component works, interact and communicate with each other, and how to integrate our changes into the existing codebase. The Tor source code is well documented, but it is still a complex codebase, with many components and interactions. The \texttt{0.4.9.1-alpha-dev} branch of the Tor source code contains nearly 1 600 files, from which 645 are \textit{C} source code files and 569 are header files, and a near total of 360 000 lines of code, including comments and empty lines, from which 290 000 correspond to \textit{C} source code files and 31 820 to \textit{C} header files. Besides \textit{C} source and header files, the Tor source code also contains \textit{Python} scripts, \textit{YAML} configuration files, and other auxiliary files. Even though the Tor source code is a very large and vast codebase, its modular and well documented structure minimizes its complexity and allows easier and faster understanding and extension. For example, inside the \texttt{src/lib} folder, where all libraries are stored, three is 448 files and 44 616 lines of code, while the entire \texttt{src} folder, which contains all the source code, has 1 458 files and 335 284 lines of code. 

Our version of the source code, with the TTT prototype, added two files in the \texttt{src/or/core} folder: \texttt{scheduler\_privacy\_kist.c}, \texttt{scheduler\_privacy\_vanilla.c}; and \texttt{dp\_mech.c} and \texttt{dp\_mech.h} in the \texttt{src/lib} folder. The first 2 files contain the implementation of the TTT schedulers, with a total of 584 lines of code. The last 2 files contain the implementation of our random number generation library with a total 236 lines of code.

In addition to the added files, the \texttt{src/or/core/relay.c} file was modified to implement the Packet Padding Cells feature, with an average of 121 added lines of code and 475 modified lines of code. We also modified the \texttt{src/or/config.c} and \texttt{src/or/or\_options\_st.h} files to extend the Tor configuration, with nearly 90 lines of code added or modified. 

Regarding the developed scripts, the \textit{Tester} script has around 640 lines of code out of 7 \textit{Bash} files, the \textit{Analyzer} script has 460 lines of code among 6 \textit{Python} files, and the \textit{Plotter} script has 416 lines of code out of 3 \textit{Python} files.

In total, this dissertation's work have developed 4 new \textit{C} files and 16 \textit{Bash} files, modified 3 \textit{C} files, leading to the addition and modification of more than 1 400 lines of code in the Tor source code and more than 1 500 lines of code in the scripts. We also developed all the needed \textit{Dockerfiles} and configuration files to run the TTT prototype in a \textit{Docker Swarm} or \textit{Docker Compose} environment, allowing for an easy and reproducible deployment of the Tor network with the TTT prototype.

In summary, the implementation of the TTT prototype required a deep understanding of the Tor architecture and mainly the scheduler component and the cell pipeline, as well as the architecture goals and rules of the Tor project.  The  development and validation of this implementation also required the study and understanding of the Differential Privacy mechanisms and mathematical distributions, as well as the reading of the Docker documentation to understand how to deploy the Tor network with the TTT prototype. This complexity study was performed using the \texttt{git diff} command to compare the actual source code with the last commit preceding the implementation of the TTT prototype, and the \texttt{cloc} command~\cite{adanial_cloc} to count the lines of code in the source code and scripts. 


\section{Prototype Availability}\label{sec:prototype_availability}
%TODO
The prototype was made available to the public to allow for further research and development and to demonstrate how to modify Tor source code and how to deploy an experimental and private Tor network with any version of source code. All  extend of the present work is divided in two repositories: a \textit{GitHub} repository with all the configuration files, scripts, the report and the Dockerfiles, and a \textit{GitLab} repository with the code of the prototype. The Tor Project official repository is available in GitLab, therefore our fork is also available there, allowing for an easy integration with the Tor Project's development process and community.

To guide anyone interested in using the TTT prototype, or reproducing the results of this dissertation, in the following sections, we explain the installation and setup process, as well as the deployment of the Tor network with the TTT prototype.


\subsection{Installation and Setup}\label{subsec:installation_and_setup}

Firstly, to create a private network, you must have a set of configuration files ready to be copied and used by the Tor nodes. We already provided a set of configuration files in the \texttt{testing/configuration} folder of the \textit{GitHub} repository, which we strongly advise you to clone and use as a starting point. 
\begin{lstlisting}[language=bash]
  $ git clone https://github.com/GoncaloRodri/Thesis.git
\end{lstlisting}

After cloning the repository, you may also clone into the repository the one we provided in the \textit{GitLab} repository\footnote{\url{https://gitlab.torproject.org/GoncaloRodri/differential-privacy-tor}}.
\begin{lstlisting}[language=bash]
  $ git clone <tor_repository> tor
\end{lstlisting}

Before running the Tor network, you must install the needed dependencies. One of the biggest dependencies is \texttt{Docker}, which we recommend you to install using the official documentation\footnote{\url{https://docs.docker.com/engine/install/}}. To run the \textit{Tester} script, you will need to run the following:
\begin{lstlisting}[language=bash]
  $ apt install jq curl ssh openssl-devel-engine
  $ snap install yq # package yq from apt may have compactability issues
\end{lstlisting}

By using \textit{Docker}, we do not need to install all Tor's dependencies, as they are already included in the \textit{Docker} image. After installing all the needed dependencies, now you can deploy the Tor network with the TTT prototype and perform any testing that you may consider adequate.

\subsection{Deployment for Validation and Testing}\label{subsec:deployment_for_validation_and_testing}

If you want to deploy the presented work in a \textit{Docker} environment, you may use the \textit{Tester} script to deploy the network. In case of testing in a local scenario, with all nodes containerized in the same machine, you may use \textit{Docker Compose}, otherwise, you may use \textit{Docker Swarm}. If using the latter, you must initiate the \textit{swarm}, join all other nodes and create a configuration file or use one of the provided in the \texttt{testing/scripts/tester} folder. 
To build all necessary Docker images from the Dockerfiles in the repository and to create a swarm and join, you must run the following commands:
\begin{lstlisting}[language=bash]
  $ docker buildx build \
        -t <docker_username>/dptor_base \
        -f testing/docker/base.Dockerfile \
        .
  $  docker buildx build \
        -t <docker_username>/dptor_node \
        -f testing/docker/node.Dockerfile \
        .
  $  docker buildx build \
        -t <docker_username>/dptor_swarm \
        -f testing/docker/swarm.Dockerfile \
        .

  $ docker swarm init 
    ## In the other nodes
  $ docker swarm join --token <token> <manager_ip>:<manager_port>  
\end{lstlisting}

It is highly recommended setting a hostname for each machine to manually allocate each container to a determined physical machine. You can set the hostname by running the following command on the swarm manager:  
\begin{lstlisting}[language=bash]
  $ docker node update --label-add <machine_hostname> <docker_node_id>
\end{lstlisting}

In case of local deployment, you just need to modify the tester script to use \textit{Docker Compose}, the correct compose file and the only preparation needed is to ensure that the Docker daemon is running, and all Docker images were built.

Finally, to run the \textit{Tester} script and deploy the network, you may run the following command:
\begin{lstlisting}[language=bash]
  $ ./testing/scripts/tester/monitor.sh -c <configuration_file>
\end{lstlisting}

However, you are also able to run the Tor network with the TTT prototype without using the \textit{Tester} script, by using only the available configuration files and running the following set of commands, after changing the torrc files accordingly to your needs:  
\begin{lstlisting}[language=bash]
  $ docker stack rm -d=false thesis
  $ docker build -f docker/swarm.Dockerfile -t dptor_swarm --no-cache . 
  $ docker stack deploy \ 
      -c testing/scripts/tester/swarm.docker-compose.yml \
      thesis
  # or 
  $ docker compose up 
\end{lstlisting}

After running the above commands, your network will be deployed and start bootstrapping. You can check the status of the network by analyzing the tor logs, which contain the phase of bootstrapping of each node. A node is ready when it reaches the \texttt{`Bootstrapped 100\%'} phase. We consider the network bootstrapped when all nodes are ready, which may take a few minutes, depending on the number of nodes and the network conditions. To check the status of the network, you can run the following command:
\begin{lstlisting}[language=bash]
  # performed for each relay
  $ grep -i "Bootstrapped 100%" <path_to_relay_logs> 
\end{lstlisting}

Finally, when the network is bootstrapped, you may use the network to run your tests. To test our prototype, we used the \texttt{curl} command to download a file from a web server, as the following command:
\begin{lstlisting}[language=bash]
  $ curl -o <output_file> --socks5 <socks_proxy> <url>
\end{lstlisting}

We recommend you to run the command in the Tor client machine. If so, as the client container shares the port 9000 to its host machine, this machine will use its container as proxy. This way, you must set the \texttt{socks\_proxy} to \texttt{127.0.0.1:9000}.

Finally, it is important to note that Tor network may take long to bootstrap, but the configuration files can also influence this time. To accelerate the process, we expect all nodes to bootstrap in less than 5 minutes, by trying multiple times until successfully connecting all nodes under the mentioned conditions. We also recommend to firstly try to deploy the network locally, to validate the solution before deploying it in a distributed environment. 

\section{Summary}\label{sec:implementation_summary}
In this chapter, we explored the implementation and prototyping details of the TTT solution by providing a detailed overview of the technical choices, technologies used, and the development process that led to the creation of the TTT prototype. We discussed the complexities involved in the implementation, the size of the Tor source code, and how we addressed them to ensure a robust and effective solution. We also explained the installation and setup process for the prototype, the deployment for validation and testing, and the availability of the prototype for further research and development.